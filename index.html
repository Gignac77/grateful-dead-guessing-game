<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DeadGuessr</title>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Comic Neue', cursive;
      text-align: center;
      padding: 2em;
      background: url('https://cdn.mos.cms.futurecdn.net/HuGGeENt6kGyixe3hT9tnY.jpg');
      background-color: #111;
      color: #eee;
      margin: 0;
    }
    .card {
      background: rgba(0, 0, 0, 0.85);
      padding: 2em;
      border-radius: 1em;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
      max-width: 600px;
      margin: auto;
      width: 90%;
      position: relative;
    }
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
    }
    .header-container h1 {
        font-size: clamp(2.4em, 10vw, 3.8em);
        color: yellow;
        margin: 0;
        font-weight: 900;
        flex-grow: 1;
    }
    .header-container h1 strong {
        font-weight: bold;
    }
    .header-container span {
        font-size: 2.2em;
        color: #228B22;
    }
    audio {
      width: 100%;
      margin: 1em 0;
      border: none;
    }
    button {
      padding: 0.6em 1.2em;
      font-size: 1.2em;
      color: white;
      border: none;
      border-radius: 0.5em;
      margin-top: 1em;
      cursor: pointer;
      font-family: 'Comic Neue', cursive;
      font-weight: bold;
      transition: background-color 0.3s, opacity 0.3s;
    }
    button:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .generate {
      background-color: #28a745;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      font-size: 1.2em;
      animation: pulse 1.5s infinite;
    }
    .reveal {
      background-color: #0066cc;
    }
    .small-button {
        padding: 0.4em 0.8em;
        font-size: 1em;
        margin-top: 0.5em;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }
    .timed {
      background-color: #9933cc;
      font-size: 1em;
      padding: 0.4em 1em;
      opacity: 0.6;
    }
    .timed.active {
      opacity: 1;
    }
    .timed-options {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 1em;
    }
    .timed-options select {
        margin-left: 0.5em;
        margin-top: 0;
    }

    .donate {
      display: inline-block;
      margin-top: 2em;
      background-color: #d63384;
      color: yellow;
      text-decoration: none;
      font-weight: bold;
      font-size: 1em;
      padding: 0.5em 1.5em;
      border-radius: 0.5em;
      font-family: 'Comic Neue', cursive;
    }
    .share {
      display: inline-block;
      margin-top: 1em;
      background-color: #4444aa;
      color: white;
      text-decoration: none;
      font-weight: bold;
      font-size: 0.9em;
      padding: 0.4em 1em;
      border-radius: 0.5em;
      font-family: 'Comic Neue', cursive;
    }
    input {
      font-size: 1em;
      padding: 0.5em;
      border-radius: 0.3em;
      border: 1px solid #ccc;
      margin-top: 1em;
      background-color: white;
      color: black;
      text-align: center;
      font-weight: bold;
      width: 6em;
      font-family: 'Comic Neue', cursive;
    }
    #result {
      margin-top: 1em;
      font-weight: bold;
      font-size: 1.5em;
      white-space: pre-line;
      min-height: 3em;
    }
    .correct {
      color: #00ff88;
      animation: glow 1.5s ease-out;
    }
    .incorrect {
      color: #ff4444;
    }
    .neutral {
      color: yellow;
    }
    .close-guess {
        color: #ffa500; /* Orange for close guesses */
    }
    .era-guess {
        color: #ffff00; /* Yellow for era matches */
    }
    #score {
      margin-top: 1em;
      font-size: 1.2em;
      color: #fff;
      background-color: rgba(255,255,255,0.1);
      border: 1px solid #eee;
      padding: 1em;
      border-radius: 1em;
    }
    #thankYou {
      margin-top: 0.5em;
      color: white;
      font-style: italic;
    }
    #timerBar {
      width: 100%;
      height: 10px;
      background: linear-gradient(to right, #00ff88, #ff0000);
      transition: width 1s linear;
      margin-top: 1em;
      border-radius: 1em;
      display: none;
    }
    @keyframes glow {
      0% { text-shadow: 0 0 5px #00ff88; }
      50% { text-shadow: 0 0 20px #00ff88; }
      100% { text-shadow: 0 0 5px #00ff88; }
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
      100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
    }
    select, button:not(.generate):not(.donate):not(.share) {
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    #gameModeIndicator {
        font-size: 1.1em;
        margin-top: 1em;
        color: #ffc107;
        font-weight: bold;
        display: none; 
    }
    .modal {
        display: none;
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.7);
        backdrop-filter: blur(5px);
    }
    .modal-content {
        background-color: #1a1a1a;
        margin: 10% auto;
        padding: 25px;
        border: 1px solid #888;
        width: 90%;
        max-width: 600px; /* Increased max-width for stats modal */
        border-radius: 1em;
        text-align: center;
        color: #fff;
        position: relative;
    }
    .modal-close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        position: absolute;
        top: 10px;
        right: 20px;
    }
    .modal-close:hover,
    .modal-close:focus {
        color: white;
        text-decoration: none;
        cursor: pointer;
    }
    #summaryGraphic, #statsContent {
        font-size: 2em;
        letter-spacing: 0.2em;
        margin: 1em 0;
    }
    #summaryDetails, #statsDetails {
        text-align: left;
        white-space: pre-wrap;
        max-height: 250px; /* Adjusted height for scrollable content */
        overflow-y: auto;
        padding-right: 10px;
        margin-bottom: 1.5em;
        font-size: 0.9em;
        line-height: 1.4;
    }
    #statsDetails h3 {
        color: #ffc107;
        margin-top: 1em;
        margin-bottom: 0.5em;
    }
    #statsDetails table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1em;
    }
    #statsDetails th, #statsDetails td {
        border: 1px solid rgba(255,255,255,0.2);
        padding: 0.5em;
        text-align: left;
    }
    #statsDetails th {
        background-color: rgba(255,255,255,0.1);
    }

    .modal-button {
        background-color: #17a2b8;
    }
    .modal-button.continue {
        background-color: #28a745;
    }

    .session-log-container {
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 0.5em;
        margin-top: 1em;
        padding: 0.5em 1em;
        text-align: left;
        color: #eee;
        max-width: 90%;
        margin-left: auto;
        margin-right: auto;
    }
    .session-log-container summary {
        font-weight: bold;
        cursor: pointer;
        padding: 0.5em 0;
        outline: none;
    }
    .session-log-container summary:hover {
        color: #ffc107;
    }
    .session-log-content {
        max-height: 250px;
        overflow-y: auto;
        padding-right: 10px;
        padding-bottom: 0.5em;
    }
    .session-log-entry {
        border-bottom: 1px dashed rgba(255,255,255,0.2);
        padding: 0.5em 0;
    }
    .session-log-entry:last-child {
        border-bottom: none;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="header-container">
      <span>⚡💀</span>
      <h1><strong>DeadGuessr</strong></h1>
      <span>💀⚡</span>
    </div>
    <p style="font-style: italic; margin-top: 0.5em; font-size: 0.9em;">1965–1995</p>

    <br />
    <audio id="audio" controls></audio>
    <br />

    <button id="goButton" class="generate" onclick="loadTrack()">Go</button>
    <br />

    <input type="text" id="yearGuess" placeholder="Year" maxlength="4" autocomplete="off" />
    <br />

    <button id="checkButton" class="reveal" onclick="revealAnswer()">Check Answer</button>
    <br />

    <select id="decadeSelect" onchange="filterByDecade(this.value)" style="display: none;">
      <option value="">All Decades</option>
      <option value="196">1960s</option>
      <option value="197">1970s</option>
      <option value="198">1980s</option>
      <option value="199">1990s</option>
    </select>
    
    <div class="timed-options" style="display: none;">
        <button class="timed" onclick="toggleTimedMode(this)">Timed Mode</button>
        <select id="timedDurationSelect">
            <option value="10">10s</option>
            <option value="20" selected>20s</option>
            <option value="30">30s</option>
            <option value="45">45s</option>
            <option value="60">60s</option>
        </select>
    </div>

    <div id="timerBar"></div>
    
    <div id="gameModeIndicator"></div>

    <p id="result" class="neutral"></p>
    <p id="score">Session Score: 0 | Total Points: 0 | Highest Score: 0 | Streak: 0</p>

    <a href="https://www.gofundme.com/f/our-friend-betty-cantorjackson-could-use-our-help" target="_blank" class="donate">🌸 Donate to Betty</a>
    <br />
    <a class="share" href="#" onclick="copyShareLink(event, false)">🔗 Share The Fun</a>
    <button id="viewStatsButton" class="reveal small-button" onclick="showStatsModal()">View My Stats</button>
    <p id="thankYou">Thank a Taper</p>
  </div>

  <div id="dailySummaryModal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeModal('dailySummaryModal')">&times;</span>
      <h2>Daily Results <span id="summaryDate" style="color: #ffc107;"></span></h2>
      <div id="summaryGraphic"></div>
      <div id="summaryDetails"></div>
      <button class="modal-button" onclick="copyShareLink(event, true)">Share Your Results</button>
    </div>
  </div>

  <div id="statsModal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeModal('statsModal')">&times;</span>
      <h2>My Overall Stats</h2>
      <div id="statsDetails"></div>
      <button class="modal-button continue" onclick="closeModal('statsModal')">Close</button>
    </div>
  </div>

<script>
let currentTrack = null;
let totalSessionGuesses = 0;
let sessionPoints = 0;
let currentStreak = 0;
let siteHighestScore = parseInt(localStorage.getItem('gd_site_highest_score')) || 0;
let allTracks = []; 
let availableTracksForSession = []; // Used to manage available tracks for the current play session
let timedMode = false; // Timed mode is currently disabled in this version
let timer = null;
let initialTimeLimit = 20; 
let timeLeft = initialTimeLimit; 
let answerRevealed = false;

// --- DAILY CHALLENGE GLOBAL VARIABLES ---
const MAX_DAILY_GUESSES = 5;
let dailyGuesses = 0; 
let dailyResults = []; 
let todaysDailySongs = []; 
let inDailyChallengeMode = true; // Always in daily challenge mode initially for 5-song rounds

// --- LIFETIME STATS GLOBAL VARIABLES ---
// Stores an array of guess objects: { timestamp, track, correctYear, guessedYear, points, diff, venue, location }
let lifetimeGuessHistory = JSON.parse(localStorage.getItem('gd_lifetimeGuessHistory')) || [];
const MAX_HISTORY_ENTRIES = 1000; // Cap history to prevent excessive localStorage usage

// --- HELPER FUNCTIONS ---

/**
 * Returns today's date in 'YYYY-MM-DD' format (UTC) for consistent seeding.
 */
function getTodayString() {
    const now = new Date();
    return now.getUTCFullYear() + '-' +
           String(now.getUTCMonth() + 1).padStart(2, '0') + '-' +
           String(now.getUTCDate()).padStart(2, '0');
}

/**
 * Returns a date in a readable format like "July 6th, 2025".
 */
function getFormattedDate(dateString) {
    const date = new Date(dateString + 'T12:00:00Z'); 
    
    const day = date.getUTCDate();
    let suffix;
    if (day > 3 && day < 21) suffix = 'th';
    else {
        switch (day % 10) {
            case 1:  suffix = 'st'; break;
            case 2:  suffix = 'nd'; break;
            case 3:  suffix = 'rd'; break;
            default: suffix = 'th';
        }
    }
    return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric' }).replace(/\d+/, day + suffix) + ', ' + date.getFullYear();
}

/**
 * Simple pseudo-random number generator for consistent shuffling based on a seed.
 */
function mulberry32(seed) {
    return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t = (t ^ t >>> 7) + (t ^ t >>> 14);
        return ((t >>> 0) / 4294967296);
    }
}

/**
 * Fisher-Yates shuffle with a seedable random function.
 */
function seededShuffle(array, randomFunc) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex != 0) {
        randomIndex = Math.floor(randomFunc() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [
            array[randomIndex], array[currentIndex]];
    }
    return array;
}

/**
 * Maps a year to a general Dead era for "Most Common Incorrect Decade"
 * This is a simplified mapping.
 */
function getEra(year) {
    if (year >= 1965 && year <= 1969) return '1960s';
    if (year >= 1970 && year <= 1974) return '1970-74';
    if (year >= 1975 && year <= 1979) return '1975-79';
    if (year >= 1980 && year <= 1985) return '1980-85';
    if (year >= 1986 && year <= 1990) return '1986-90';
    if (year >= 1991 && year <= 1995) return '1991-95';
    return 'Unknown';
}


// --- CORE GAME LOGIC ---

document.addEventListener('DOMContentLoaded', async () => {
    await loadTracksJson(); 
    checkDailyStatus(); 
    updateScoreDisplay(); // Initialize score display

    // Set initial message and UI state based on game mode
    if (dailyGuesses === 0) {
        document.getElementById('result').textContent = 'Press "Go" to start your 5-song round!';
    } else if (dailyGuesses < MAX_DAILY_GUESSES) {
        const guessesLeft = MAX_DAILY_GUESSES - dailyGuesses;
        document.getElementById('result').textContent = `Round in progress: ${guessesLeft} song${guessesLeft === 1 ? '' : 's'} left. Press "Next".`;
        document.getElementById('goButton').textContent = 'Next';
    } else {
        document.getElementById('result').textContent = 'Daily round complete! Check back tomorrow for a new challenge.';
        document.getElementById('goButton').disabled = true; // Disable go button after 5 guesses
    }
    updateGameModeUI();
});

async function loadTracksJson() {
    try {
        const res = await fetch('tracks.json');
        allTracks = await res.json();
    } catch (error) {
        console.error('Error loading tracks.json:', error);
        document.getElementById('result').textContent = 'Could not load tracks. Please refresh!';
    }
}

/**
 * Manages the daily song queue and user progress for the 5-song round.
 */
function checkDailyStatus() {
    const lastPlayDate = localStorage.getItem('gd_lastPlayDate');
    const today = getTodayString();

    if (lastPlayDate === today) {
        dailyGuesses = parseInt(localStorage.getItem('gd_dailyGuesses')) || 0;
        dailyResults = JSON.parse(localStorage.getItem('gd_dailyResults')) || [];
        sessionPoints = parseInt(localStorage.getItem('gd_sessionPoints')) || 0; // Restore session points
        currentStreak = parseInt(localStorage.getItem('gd_currentStreak')) || 0; // Restore streak
        totalSessionGuesses = dailyGuesses; // Sync totalSessionGuesses with dailyGuesses
    } else {
        // New day, reset everything for daily challenge
        localStorage.setItem('gd_lastPlayDate', today);
        localStorage.setItem('gd_dailyGuesses', '0');
        localStorage.setItem('gd_dailyResults', '[]');
        localStorage.setItem('gd_sessionPoints', '0');
        localStorage.setItem('gd_currentStreak', '0');
        dailyGuesses = 0;
        dailyResults = [];
        sessionPoints = 0;
        currentStreak = 0;
        totalSessionGuesses = 0; // Reset session guesses for new day
        siteHighestScore = parseInt(localStorage.getItem('gd_site_highest_score')) || 0; // Keep site high score
    }
    // Always fetch today's universal songs, even if daily guesses are done, for summary display
    todaysDailySongs = getTodaysUniversalSongs(); 
    updateGameModeUI();
}

/**
 * Gets the 5 universal songs for today's daily challenge using a seeded shuffle.
 * Manages a global shuffled queue in localStorage that all users draw from.
 */
function getTodaysUniversalSongs() {
    const today = getTodayString();
    const dateSeed = parseInt(today.replace(/-/g, '')); 
    const random = mulberry32(dateSeed); 

    let globalQueue = JSON.parse(localStorage.getItem('gd_globalSongQueue')) || [];
    let globalQueueIndex = parseInt(localStorage.getItem('gd_globalQueueIndex')) || 0;
    let lastQueueShuffleDate = localStorage.getItem('gd_lastQueueShuffleDate');

    // Check for new tracks or if the queue needs to be re-shuffled (e.g., new day or exhausted)
    const currentTrackFilenames = new Set(allTracks.map(t => t.filename));
    const queueFilenames = new Set(globalQueue.map(t => t.filename));
    const missingTracks = [...currentTrackFilenames].filter(f => !queueFilenames.has(f));

    if (globalQueue.length === 0 || globalQueueIndex >= globalQueue.length || missingTracks.length > 0 || lastQueueShuffleDate !== today) {
        console.log('Resetting/Updating global song queue due to exhaustion, new tracks, or new day.');
        globalQueue = [...allTracks]; 
        globalQueue = seededShuffle(globalQueue, random); 
        
        if (lastQueueShuffleDate !== today) {
            // Move index forward by MAX_DAILY_GUESSES for a new day to get a new set of songs
            let previousIndex = parseInt(localStorage.getItem('gd_globalQueueIndex')) || 0;
            globalQueueIndex = (previousIndex + MAX_DAILY_GUESSES) % globalQueue.length;
        } else {
            // If it's the same day but the queue was exhausted/updated, reset index to 0
            globalQueueIndex = 0;
        }

        localStorage.setItem('gd_globalSongQueue', JSON.stringify(globalQueue));
        localStorage.setItem('gd_globalQueueIndex', globalQueueIndex.toString());
        localStorage.setItem('gd_lastQueueShuffleDate', today); 
    }
    
    const dailySongs = [];
    for (let i = 0; i < MAX_DAILY_GUESSES; i++) {
        const songIndex = (globalQueueIndex + i) % globalQueue.length; 
        dailySongs.push(globalQueue[songIndex]);
    }
    return dailySongs;
}

function updateGameModeUI() {
    const indicator = document.getElementById('gameModeIndicator');
    const goButton = document.getElementById('goButton');

    if (dailyGuesses < MAX_DAILY_GUESSES) {
        const guessesLeft = MAX_DAILY_GUESSES - dailyGuesses;
        indicator.textContent = `Daily Challenge: ${dailyGuesses + 1}/${MAX_DAILY_GUESSES} Songs`;
        indicator.style.display = 'block'; 
        goButton.disabled = false; // Ensure go button is enabled during the round
        goButton.textContent = (dailyGuesses === 0 && !currentTrack) ? 'Go' : 'Next';
    } else {
        indicator.textContent = `Daily Challenge Complete!`;
        indicator.style.display = 'block'; 
        goButton.disabled = true; // Disable go button after 5 guesses
        goButton.textContent = 'Go'; // Reset button text
    }
    // Ensure decade select and timed mode are always hidden in this game structure
    document.getElementById('decadeSelect').style.display = 'none';
    document.getElementById('timedDurationSelect').style.display = 'none';
    document.querySelector('.timed-options').style.display = 'none';
}

/**
 * Loads the next track for the 5-song daily round.
 */
function loadTrack() {
    if (dailyGuesses >= MAX_DAILY_GUESSES) {
        document.getElementById('result').textContent = 'Daily round complete! Check back tomorrow for a new challenge.';
        document.getElementById('goButton').disabled = true;
        return;
    }

    const track = todaysDailySongs[dailyGuesses];
    if (!track) {
        document.getElementById('result').textContent = 'Error loading track. Please refresh!';
        return;
    }
    
    currentTrack = track;
    answerRevealed = false;
    document.getElementById('audio').src = `audio/${track.filename}`;
    document.getElementById('audio').load();
    document.getElementById('audio').play().catch(() => {});
    document.getElementById('result').textContent = '';
    document.getElementById('result').className = 'neutral';
    document.getElementById('yearGuess').value = '';
    document.getElementById('checkButton').disabled = false;
    
    // Timed mode related elements are conceptually disabled for this version
    clearInterval(timer);
    document.getElementById('timerBar').style.display = 'none';
}

function revealAnswer() {
    if (!currentTrack || answerRevealed) return;
    answerRevealed = true;
    clearInterval(timer);
    document.getElementById('timerBar').style.display = 'none';
    document.getElementById('checkButton').disabled = true;

    let guessInput = document.getElementById('yearGuess').value.trim();
    let guessedYearNum = parseInt(guessInput, 10);
    let displayGuess = guessInput; // What we show to the user

    // Handle 2-digit year input for display only, still use 4-digit for calculation
    if (/^\d{2}$/.test(guessInput)) {
        guessedYearNum = (guessedYearNum >= 65 && guessedYearNum <= 99 ? 1900 : 2000) + guessedYearNum;
        displayGuess = guessedYearNum.toString();
    } else if (!/^\d{4}$/.test(guessInput) || isNaN(guessedYearNum)) {
        guessedYearNum = null; // No valid guess
        displayGuess = 'No guess';
    }

    const correctYear = parseInt(currentTrack.year, 10);
    const difference = guessedYearNum !== null ? Math.abs(guessedYearNum - correctYear) : Infinity;

    let pointsEarned = 0;
    let resultClass = 'incorrect';
    let message = 'Not Quite!';
    let isPerfect = false;
    let isClose = false;
    let isEra = false;

    if (guessedYearNum === correctYear) {
        pointsEarned = 100;
        resultClass = 'correct';
        message = 'Correct!';
        isPerfect = true;
        currentStreak++;
    } else if (difference <= 1) {
        pointsEarned = 75;
        resultClass = 'close-guess';
        message = `Very Close! (${difference} year${difference === 1 ? '' : 's'} off)`;
        isClose = true;
        currentStreak = 0; // Reset streak on non-perfect
    } else if (difference <= 2) {
        pointsEarned = 50;
        resultClass = 'close-guess';
        message = `Close! (${difference} year${difference === 1 ? '' : 's'} off)`;
        isClose = true;
        currentStreak = 0;
    } else if (difference <= 5) { // Era match: within 5 years
        pointsEarned = 25;
        resultClass = 'era-guess';
        message = `Era Match! (${difference} year${difference === 1 ? '' : 's'} off)`;
        isEra = true;
        currentStreak = 0;
    } else {
        pointsEarned = 0;
        resultClass = 'incorrect';
        message = `Not Quite! (${guessedYearNum !== null ? difference : '??'} year${difference === 1 ? '' : 's'} off)`;
        currentStreak = 0;
    }

    sessionPoints += pointsEarned;
    totalSessionGuesses++;

    // Update global high score if session points exceed it
    if (sessionPoints > siteHighestScore) {
        siteHighestScore = sessionPoints;
        localStorage.setItem('gd_site_highest_score', siteHighestScore);
    }
    localStorage.setItem('gd_sessionPoints', sessionPoints);
    localStorage.setItem('gd_currentStreak', currentStreak);

    // Store daily result
    dailyResults.push({
        correct: isPerfect,
        close: isClose,
        era: isEra, // New field for era match
        guess: displayGuess,
        points: pointsEarned,
        trackInfo: `${currentTrack.track} (${currentTrack.year})`
    });
    dailyGuesses++; 
    localStorage.setItem('gd_dailyGuesses', dailyGuesses.toString());
    localStorage.setItem('gd_dailyResults', JSON.stringify(dailyResults));

    // Store lifetime guess history
    lifetimeGuessHistory.push({
        timestamp: new Date().toISOString(),
        track: currentTrack.track,
        correctYear: currentTrack.year,
        guessedYear: displayGuess,
        points: pointsEarned,
        diff: guessedYearNum !== null ? difference : null,
        venue: currentTrack.venue,
        location: currentTrack.location
    });

    // Prune history if it gets too large
    if (lifetimeGuessHistory.length > MAX_HISTORY_ENTRIES) {
        console.warn('Lifetime guess history is getting large. Pruning oldest entries.');
        lifetimeGuessHistory = lifetimeGuessHistory.slice(lifetimeGuessHistory.length - MAX_HISTORY_ENTRIES / 2); // Keep last half
    }
    localStorage.setItem('gd_lifetimeGuessHistory', JSON.stringify(lifetimeGuessHistory));


    const resultEl = document.getElementById('result');
    resultEl.className = resultClass;
    resultEl.textContent = `${message}\nYou guessed: ${displayGuess} — Correct Year: ${currentTrack.year}\nPoints: ${pointsEarned}\n\nSong: ${currentTrack.track}\nDate: ${currentTrack.date}\n${currentTrack.venue}, ${currentTrack.location}`;
    
    updateScoreDisplay();
    updateGameModeUI(); 

    if (dailyGuesses >= MAX_DAILY_GUESSES) {
        showDailySummary(); // Show summary after the last guess
    }
}

function showDailySummary() {
    const modal = document.getElementById('dailySummaryModal');
    document.getElementById('summaryDate').textContent = `(${getFormattedDate(getTodayString())})`;
    const graphicEl = document.getElementById('summaryGraphic');
    const detailsEl = document.getElementById('summaryDetails');
    
    let graphic = dailyResults.map(r => {
        if (r.correct) return '🟩';
        if (r.close) return '🟨'; // Yellow for close (1-2 years off)
        if (r.era) return '🟨'; // Also yellow for era (3-5 years off) - could use a different emoji if desired
        return '🟥';
    }).join(' ');

    let totalDailyPoints = dailyResults.reduce((sum, r) => sum + r.points, 0);
    let dailyPerfect = dailyResults.filter(r => r.correct).length;
    let dailyClose = dailyResults.filter(r => r.close).length;
    let dailyEra = dailyResults.filter(r => r.era).length;

    detailsEl.innerHTML = `
        <strong>Your Round Score: ${totalDailyPoints} Points</strong><br>
        Perfect Guesses: ${dailyPerfect}<br>
        Close Guesses ($\pm2$ years): ${dailyClose}<br>
        Era Matches ($\pm5$ years): ${dailyEra}<br><br>
        ${dailyResults.map((result, index) => {
            let statusIcon = '❌';
            if (result.correct) statusIcon = '✅';
            else if (result.close || result.era) statusIcon = '🔶'; // Orange for any proximity
            return `${statusIcon} Guess ${index + 1}: ${result.trackInfo} | Your Guess: ${result.guess} | Points: ${result.points}`;
        }).join('\n')}
    `;
    modal.style.display = 'block';
}

function showStatsModal() {
    const modal = document.getElementById('statsModal');
    const statsDetailsEl = document.getElementById('statsDetails');

    const totalGames = lifetimeGuessHistory.length;
    const totalLifetimePoints = lifetimeGuessHistory.reduce((sum, guess) => sum + guess.points, 0);
    const lifetimePerfectGuesses = lifetimeGuessHistory.filter(g => g.points === 100).length;
    const lifetimeCloseGuesses = lifetimeGuessHistory.filter(g => g.points === 75 || g.points === 50).length;
    const lifetimeEraMatches = lifetimeGuessHistory.filter(g => g.points === 25).length;
    
    const perfectAccuracy = totalGames > 0 ? ((lifetimePerfectGuesses / totalGames) * 100).toFixed(1) : 0;
    const overallSuccessRate = totalGames > 0 ? (((lifetimePerfectGuesses + lifetimeCloseGuesses + lifetimeEraMatches) / totalGames) * 100).toFixed(1) : 0;

    // Calculate average difference for valid numerical guesses
    const validDifferences = lifetimeGuessHistory
        .filter(g => g.diff !== null && !isNaN(g.diff))
        .map(g => g.diff);
    const averageDifference = validDifferences.length > 0 ? (validDifferences.reduce((sum, diff) => sum + diff, 0) / validDifferences.length).toFixed(1) : 'N/A';

    // Calculate most common incorrect decade
    const incorrectDecades = {};
    lifetimeGuessHistory.forEach(guess => {
        if (guess.points === 0 && guess.guessedYear !== 'No guess' && guess.guessedYear) {
            const guessedYear = parseInt(guess.guessedYear, 10);
            if (!isNaN(guessedYear)) {
                const decade = Math.floor(guessedYear / 10) * 10 + 's';
                incorrectDecades[decade] = (incorrectDecades[decade] || 0) + 1;
            }
        }
    });
    let mostCommonIncorrectDecade = 'N/A';
    let maxIncorrectCount = 0;
    for (const decade in incorrectDecades) {
        if (incorrectDecades[decade] > maxIncorrectCount) {
            maxIncorrectCount = incorrectDecades[decade];
            mostCommonIncorrectDecade = decade;
        }
    }

    // Prepare yearly breakdown
    const yearlyBreakdown = lifetimeGuessHistory.reduce((acc, guess) => {
        if (guess.correctYear) {
            const year = guess.correctYear;
            acc[year] = acc[year] || { games: 0, points: 0 };
            acc[year].games++;
            acc[year].points += guess.points;
        }
        return acc;
    }, {});
    const sortedYears = Object.keys(yearlyBreakdown).sort();

    // Prepare venue breakdown
    const venueBreakdown = lifetimeGuessHistory.reduce((acc, guess) => {
        if (guess.venue) {
            const venue = guess.venue;
            acc[venue] = acc[venue] || { games: 0, points: 0 };
            acc[venue].games++;
            acc[venue].points += guess.points;
        }
        return acc;
    }, {});
    const sortedVenues = Object.keys(venueBreakdown).sort((a,b) => venueBreakdown[b].points - venueBreakdown[a].points); // Sort by points descending

    let statsHtml = `
        <h3>Overall Performance</h3>
        <p><strong>Total Games Played:</strong> ${totalGames}</p>
        <p><strong>Total Points Earned:</strong> ${totalLifetimePoints}</p>
        <p><strong>Perfect Guesses:</strong> ${lifetimePerfectGuesses} (${perfectAccuracy}%)</p>
        <p><strong>Close Guesses (±2 years):</strong> ${lifetimeCloseGuesses}</p>
        <p><strong>Era Matches (±5 years):</strong> ${lifetimeEraMatches}</p>
        <p><strong>Overall Success Rate (Perfect + Close + Era):</strong> ${overallSuccessRate}%</p>
        <p><strong>Highest Streak:</strong> ${localStorage.getItem('gd_lifetimeHighestStreak') || 0}</p>
        <p><strong>Average Year Difference (Incorrect Guesses):</strong> ${averageDifference} years</p>
        <p><strong>Most Common Incorrect Decade:</strong> ${mostCommonIncorrectDecade}</p>
        <p><em>(Stats are updated after each guess and saved in your browser.)</em></p>
        
        <h3>Year-by-Year Performance</h3>
        <table>
            <thead><tr><th>Year</th><th>Games</th><th>Points</th></tr></thead>
            <tbody>
                ${sortedYears.map(year => `<tr><td>${year}</td><td>${yearlyBreakdown[year].games}</td><td>${yearlyBreakdown[year].points}</td></tr>`).join('')}
            </tbody>
        </table>

        <h3>Top Venues (by Points)</h3>
        <table>
            <thead><tr><th>Venue</th><th>Games</th><th>Points</th></tr></thead>
            <tbody>
                ${sortedVenues.map(venue => `<tr><td>${venue}</td><td>${venueBreakdown[venue].games}</td><td>${venueBreakdown[venue].points}</td></tr>`).join('')}
            </tbody>
        </table>

        <h3>Full Guess History</h3>
        <div style="max-height: 200px; overflow-y: auto; text-align: left; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 0.5em;">
            ${lifetimeGuessHistory.length === 0 ? '<p>No guess history yet.</p>' :
                lifetimeGuessHistory.slice().reverse().map(g => `
                    <p style="border-bottom: 1px dashed rgba(255,255,255,0.1); padding-bottom: 5px; margin-bottom: 5px;">
                        <strong>${getFormattedDate(g.timestamp.split('T')[0])}:</strong> ${g.track} (${g.correctYear})<br>
                        Guessed: ${g.guessedYear} | Points: ${g.points} ${g.diff !== null ? `(${g.diff} off)` : ''}
                        <br><small>${g.venue}, ${g.location}</small>
                    </p>
                `).join('')
            }
        </div>
    `;

    statsDetailsEl.innerHTML = statsHtml;
    modal.style.display = 'block';
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
}

function copyShareLink(event, isFromResultModal) {
    event.preventDefault();
    let shareText;
    if (isFromResultModal && dailyResults.length > 0) {
        const graphic = dailyResults.map(r => {
            if (r.correct) return '🟩';
            if (r.close || r.era) return '🟨';
            return '🟥';
        }).join('');
        const totalDailyPoints = dailyResults.reduce((sum, r) => sum + r.points, 0);
        const dailyPerfect = dailyResults.filter(r => r.correct).length;
        const dailyClose = dailyResults.filter(r => r.close).length;
        const dailyEra = dailyResults.filter(r => r.era).length;

        shareText = `DeadGuessr Daily Challenge ${getFormattedDate(getTodayString())}\nMy Round Score: ${totalDailyPoints} points! (${dailyPerfect} Perfect, ${dailyClose} Close, ${dailyEra} Era)\n${graphic}\n\nPlay here: ${window.location.href}`;
    } else {
        shareText = `I'm testing my Dead knowledge on DeadGuessr! Come play along and guess the year: ${window.location.href}`;
    }

    navigator.clipboard.writeText(shareText).then(() => {
        alert('Results copied to clipboard!');
    }).catch(err => console.error('Failed to copy: ', err));
}

function updateScoreDisplay() {
    // We'll update highest streak based on lifetimeGuessHistory, not session streak, to be consistent.
    // However, currentStreak is for the current session.
    let lifetimeHighestStreak = 0;
    let currentConsecutiveCorrect = 0;
    for (let i = 0; i < lifetimeGuessHistory.length; i++) {
        if (lifetimeGuessHistory[i].points === 100) {
            currentConsecutiveCorrect++;
        } else {
            currentConsecutiveCorrect = 0;
        }
        if (currentConsecutiveCorrect > lifetimeHighestStreak) {
            lifetimeHighestStreak = currentConsecutiveCorrect;
        }
    }
    localStorage.setItem('gd_lifetimeHighestStreak', lifetimeHighestStreak);


    document.getElementById('score').textContent = `Session Score: ${sessionPoints} | Total Points: ${siteHighestScore} | Streak: ${currentStreak}`;
}

// Timed mode related functions are kept but effectively disabled in current UI
function toggleTimedMode(btn) {
    // This functionality is currently disabled for the 5-song round structure
    alert("Timed mode is not available in the current 5-song round structure.");
}

function startTimer() {
    // This functionality is currently disabled for the 5-song round structure
}

function filterByDecade(decadePrefix) {
    // This functionality is currently disabled for the 5-song round structure
    alert("Decade filtering is not available in the current 5-song round structure.");
}

document.addEventListener('keydown', function(event) {
    if (document.activeElement === document.getElementById('yearGuess') && event.key === 'Enter') {
        event.preventDefault();
        if (!answerRevealed) revealAnswer();
    }
});
</script>

<footer style="font-size: 0.8em; text-align: center; margin-top: 2em; color: #ccc;">
  <a href="https://github.com/Gignac77" target="_blank" rel="noopener noreferrer" style="color: #ccc; text-decoration: none;">
    Built with Love by Matt
  </a>
</footer>
</body>
</html>
