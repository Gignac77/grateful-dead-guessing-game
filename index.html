<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DeadGuessr</title>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Comic Neue', cursive;
      text-align: center;
      padding: 2em;
      background: url('https://cdn.mos.cms.futurecdn.net/HuGGeENt6kGyixe3hT9tnY.jpg');
      background-color: #111;
      color: #eee;
      margin: 0;
    }
    .card {
      background: rgba(0, 0, 0, 0.85);
      padding: 2em;
      border-radius: 1em;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
      max-width: 600px;
      margin: auto;
      width: 90%;
      position: relative;
    }
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
    }
    .header-container h1 {
        font-size: clamp(2.4em, 10vw, 3.8em);
        color: yellow;
        margin: 0;
        font-weight: 900;
        flex-grow: 1;
    }
    .header-container h1 strong {
        font-weight: bold;
    }
    .header-container span {
        font-size: 2.2em;
        color: #228B22;
    }
    audio {
      width: 100%;
      margin: 1em 0;
      border: none;
    }
    button {
      padding: 0.6em 1.2em;
      font-size: 1.2em;
      color: white;
      border: none;
      border-radius: 0.5em;
      margin-top: 1em;
      cursor: pointer;
      font-family: 'Comic Neue', cursive;
      font-weight: bold;
      transition: background-color 0.3s, opacity 0.3s;
    }
    button:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .generate {
      background-color: #28a745;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      font-size: 1.2em;
      animation: pulse 1.5s infinite;
    }
    .reveal {
      background-color: #0066cc;
    }
    .daily-challenge-button {
      background-color: #ff8c00; /* Orange color for daily challenge */
      padding: 0.8em 1.5em;
      width: auto; /* Allow button to size based on content */
      height: auto;
      border-radius: 0.5em; /* Make it a regular button shape */
      font-size: 1.1em;
      margin-top: 1.5em; /* Adjust margin to fit logically */
    }
    .small-button {
        padding: 0.4em 0.8em;
        font-size: 1em;
        margin-top: 0.5em;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }
    .timed {
      background-color: #9933cc;
      font-size: 1em;
      padding: 0.4em 1em;
      opacity: 0.6;
    }
    .timed.active {
      opacity: 1;
    }
    .timed-options {
        display: flex;
        justify-content: center;
        align-items: center;
        /* margin-top is handled by parent .controls-group */
    }
    .timed-options select {
        margin-left: 0.5em;
        margin-top: 0;
    }

    .donate {
      display: inline-block;
      margin-top: 2em;
      background-color: #d63384;
      color: yellow;
      text-decoration: none;
      font-weight: bold;
      font-size: 1em;
      padding: 0.5em 1.5em;
      border-radius: 0.5em;
      font-family: 'Comic Neue', cursive;
    }
    .share {
      display: inline-block;
      margin-top: 1em;
      background-color: #4444aa;
      color: white;
      text-decoration: none;
      font-weight: bold;
      font-size: 0.9em;
      padding: 0.4em 1em;
      border-radius: 0.5em;
      font-family: 'Comic Neue', cursive;
    }
    input {
      font-size: 1em;
      padding: 0.5em;
      border-radius: 0.3em;
      border: 1px solid #ccc;
      margin-top: 1em;
      background-color: white;
      color: black;
      text-align: center;
      font-weight: bold;
      width: 6em;
      font-family: 'Comic Neue', cursive;
    }
    #result {
      margin-top: 1em;
      font-weight: bold;
      font-size: 1.5em; /* Consistent font size for result and song info */
      white-space: pre-line;
      min-height: 3em;
    }
    #songInfoDisplay {
        font-size: 1.5em; /* Match #result font size */
        color: #ddd;
        margin-top: 0.5em;
        white-space: pre-line;
    }
    #yearInputGuidance { /* Style for the new guidance text */
        font-size: 0.8em;
        color: #aaa;
        margin-top: 0.5em;
        display: none; /* Hidden by default */
    }
    .correct {
      color: #00ff88;
      animation: glow 1.5s ease-out;
    }
    .incorrect {
      color: #ff4444;
    }
    .neutral {
      color: yellow;
    }
    .close-guess {
        color: #ffa500; /* Orange for close guesses */
    }
    .era-guess {
        color: #ffff00; /* Yellow for era matches */
    }
    #score {
      margin-top: 1em;
      font-size: 1.2em;
      color: #fff;
      background-color: rgba(255,255,255,0.1);
      border: 1px solid #eee;
      padding: 1em;
      border-radius: 1em;
    }
    #score span { /* Style for animating score numbers */
        display: inline-block;
        min-width: 20px; /* Prevent reflow during animation */
        text-align: center;
    }
    #thankYou {
      margin-top: 0.5em;
      color: white;
      font-style: italic;
    }
    #timerBar {
      width: 100%;
      height: 10px;
      background: linear-gradient(to right, #00ff88, #ff0000);
      transition: width 1s linear;
      margin-top: 1em;
      border-radius: 1em;
      display: none; /* Hidden by default, only shown when timed mode active */
    }
    @keyframes glow {
      0% { text-shadow: 0 0 5px #00ff88; }
      50% { text-shadow: 0 0 20px #00ff88; }
      100% { text-shadow: 0 0 5px #00ff88; }
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
      100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
    }
    
    /* Centering and uniform sizing for controls */
    .controls-group {
        display: flex;
        justify-content: center;
        align-items: center; /* Vertically align items */
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
        gap: 1em; /* Space between elements */
        margin-top: 1em; /* Adjust margin as needed */
    }

    .controls-group select,
    .timed-options button,
    .timed-options select {
        padding: 0.6em 1.2em; /* Match button padding for vertical size */
        font-size: 1.2em; /* Ensure consistent font size */
        border-radius: 0.5em; /* Consistent with buttons */
        border: none; /* Remove default select border */
        appearance: none; /* Remove default select arrow on some browsers */
        background-color: #444; /* Darker background for consistency */
        color: white; /* White text */
        min-width: 100px; /* Ensure a minimum width */
        height: 3em; /* Explicit height to unify vertical size, adjust as needed */
        box-sizing: border-box; /* Include padding/border in height */
        cursor: pointer;
        font-family: 'Comic Neue', cursive;
        font-weight: bold;
        text-align: center; /* Center text in dropdown */
        text-align-last: center; /* For Firefox */
    }

    /* Custom arrow for select element when appearance: none is used */
    .controls-group select {
        background-image: linear-gradient(45deg, transparent 50%, white 50%),
                          linear-gradient(135deg, white 50%, transparent 50%),
                          linear-gradient(to right, #444, #444);
        background-position: calc(100% - 15px) calc(1em + 2px), /* Arrow top */
                             calc(100% - 10px) calc(1em + 2px), /* Arrow bottom */
                             100% 0; /* Background for arrow area */
        background-size: 5px 5px,
                         5px 5px,
                         2.5em 2.5em;
        background-repeat: no-repeat;
    }

    #gameModeIndicator {
        font-size: 1.1em;
        margin-top: 1em;
        color: #ffc107;
        font-weight: bold;
        display: none; 
    }
    .modal {
        display: none;
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.7);
        backdrop-filter: blur(5px);
    }
    .modal-content {
        background-color: #1a1a1a;
        margin: 10% auto;
        padding: 25px;
        border: 1px solid #888;
        width: 90%;
        max-width: 600px; /* Increased max-width for stats modal */
        border-radius: 1em;
        text-align: center;
        color: #fff;
        position: relative;
    }
    .modal-close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        position: absolute;
        top: 10px;
        right: 20px;
    }
    .modal-close:hover,
    .modal-close:focus {
        color: white;
        text-decoration: none;
        cursor: pointer;
    }
    #summaryGraphic { /* Specific style for daily summary graphic */
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        margin: 1em 0;
        gap: 5px;
        background: rgba(255,255,255,0.1);
        padding: 15px;
        border-radius: 8px;
        min-height: 80px;
    }
    .summary-block {
        width: 60px; /* Size of each block */
        height: 60px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border-radius: 5px;
        font-size: 0.8em;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    .summary-block.perfect { background-color: #28a745; } /* Green */
    .summary-block.close { background-color: #ffc107; }    /* Yellow/Orange */
    .summary-block.miss { background-color: #dc3545; }     /* Red */


    #summaryDetails, #statsDetails {
        text-align: left;
        white-space: pre-wrap;
        max-height: 250px; /* Adjusted height for scrollable content */
        overflow-y: auto;
        padding-right: 10px;
        margin-bottom: 1.5em;
        font-size: 0.9em;
        line-height: 1.4;
    }
    #statsDetails h3 {
        color: #ffc107;
        margin-top: 1em;
        margin-bottom: 0.5em;
    }
    #statsDetails hr {
        border: 0;
        height: 1px;
        background-image: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.75), rgba(255, 255, 255, 0));
        margin: 1em 0;
    }
    #statsDetails table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1em;
        margin-bottom: 1em;
    }
    #statsDetails th, #statsDetails td {
        border: 1px solid rgba(255,255,255,0.2);
        padding: 0.5em;
        text-align: left;
    }
    #statsDetails th {
        background-color: rgba(255,255,255,0.1);
    }

    .modal-button {
        background-color: #17a2b8;
    }
    .modal-button.continue {
        background-color: #28a745;
    }

    .scoring-system-container {
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 0.5em;
        margin-top: 1em;
        padding: 0.5em 1em;
        text-align: left;
        color: #eee;
        max-width: 90%;
        margin-left: auto;
        margin-right: auto;
    }
    .scoring-system-container summary {
        font-weight: bold;
        cursor: pointer;
        padding: 0.5em 0;
        outline: none;
    }
    .scoring-system-container summary:hover {
        color: #ffc107;
    }
    .scoring-system-content {
        padding-top: 0.5em;
        font-size: 0.9em;
    }
    .scoring-system-content p {
        margin-bottom: 0.5em;
    }
    .scoring-system-content strong {
        color: #ffc107;
    }

    /* New styles for the scoring info modal */
    #scoringInfoModal .modal-content {
        max-width: 450px; /* Smaller width for this specific modal */
    }
    #scoringInfoModal .modal-content p {
        margin-bottom: 0.8em;
    }
    #scoringInfoModal .modal-content strong {
        color: #ffc107;
    }
    #scoringInfoModal .modal-content small {
        display: block; /* Ensures small text is on its own line */
        margin-top: 0.2em;
        color: #bbb;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="header-container">
      <span>‚ö°üíÄ</span>
      <h1><strong>DeadGuessr</strong></h1>
      <span>üíÄ‚ö°</span>
    </div>
    <p style="font-style: italic; margin-top: 0.5em; font-size: 0.9em;">1965‚Äì1995</p>

    <br />
    <audio id="audio" controls></audio>
    <br />

    <button id="goButton" class="generate" onclick="loadTrack()">Go</button>
    <br />

    <input type="text" id="yearGuess" placeholder="Year" maxlength="4" autocomplete="off" />
    <p id="yearInputGuidance">Tip: You can use two digits (e.g., '72' for 1972)!</p>
    <br />

    <button id="checkButton" class="reveal" onclick="revealAnswer()">Check Answer</button>
    <br />

    <div class="controls-group">
        <select id="decadeSelect" onchange="filterByDecade(this.value)">
            <option value="">All Decades</option>
            <option value="196">1960s</option>
            <option value="197">1970s</option>
            <option value="198">1980s</option>
            <option value="199">1990s</option>
        </select>
        
        <div class="timed-options">
            <button class="timed" onclick="toggleTimedMode(this)">Timed Mode</button>
            <select id="timedDurationSelect">
                <option value="10">10s</option>
                <option value="20" selected>20s</option>
                <option value="30">30s</option>
                <option value="45">45s</option>
                <option value="60">60s</option>
            </select>
        </div>
    </div>

    <div id="timerBar"></div>
    
    <div id="gameModeIndicator"></div> <p id="result" class="neutral"></p>
    <p id="songInfoDisplay"></p> <p id="score">Session Score: <span id="sessionScoreValue">0</span> | Highest Score: <span id="highestScoreValue">0</span> | Perfect Guess Streak: <span id="streakValue">0</span></p>

    <button class="small-button reveal" onclick="showScoringInfoModal()">How is Scoring Calculated?</button>

    <button id="dailyChallengeButton" class="daily-challenge-button" onclick="startDailyChallenge()">Play Daily Challenge</button>

    <a href="https://www.gofundme.com/f/our-friend-betty-cantorjackson-could-use-our-help" target="_blank" class="donate">üå∏ Donate to Betty</a>
    <br />
    <a class="share" href="#" onclick="copyShareLink(event, false)">üîó Share The Fun</a>
    <button id="viewStatsButton" class="reveal small-button" onclick="showStatsModal()">View My Stats</button>
    <p id="thankYou">Thank a Taper</p>
  </div>

  <div id="dailySummaryModal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeModal('dailySummaryModal')">&times;</span>
      <h2>Daily Results <span id="summaryDate" style="color: #ffc107;"></span></h2>
      <div id="summaryGraphic"></div> <hr>
      <div id="summaryDetails"></div> <button class="modal-button" onclick="copyShareLink(event, true)">Share Your Results</button>
      <button class="modal-button continue" onclick="closeDailySummaryAndEnterFreePlay()">Continue to Free Play</button>
    </div>
  </div>

  <div id="statsModal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeModal('statsModal')">&times;</span>
      <h2>My Overall Stats</h2>
      <div id="statsDetails"></div>
      <button class="modal-button continue" onclick="closeModal('statsModal')">Close</button>
    </div>
  </div>

  <div id="scoringInfoModal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeModal('scoringInfoModal')">&times;</span>
      <h2>How Scoring Works</h2>
      <p><strong>100 Points: Perfect Guess</strong><br><small><em>(Exactly 0 years off)</em></small></p>
      <p><strong>75 Points: Very Close</strong><br><small><em>($\pm1$ year off)</em></small></p>
      <p><strong>50 Points: Close Guess</strong><br><small><em>($\pm2$ years off)</em></small></p>
      <p><strong>25 Points: Era Match</strong><br><small><em>($\pm3$ to $\pm5$ years off)</em></small></p>
      <p><strong>0 Points: Incorrect</strong><br><small><em>(More than 5 years off)</em></small></p>
      <hr>
      <p>Your "Session Score" tracks points in the current play session. "Highest Score" is your all-time best score from any single session.</p>
      <p>All your stats are saved directly in your browser's local storage. If you clear your browser data, your stats will be reset.</p>
      <button class="modal-button continue" onclick="closeModal('scoringInfoModal')">Got It!</button>
    </div>
  </div>

<script>
let currentTrack = null;
let sessionPoints = 0; // Points for current browser session (Free Play)
let currentStreak = 0; // Current streak of perfect guesses
let siteHighestScore = parseInt(localStorage.getItem('gd_site_highest_score')) || 0; // All-time highest session points
let allTracks = []; 
let availableTracksForSession = []; // Tracks available for current Free Play session, respects filters
let timedMode = false;
let timer = null;
let initialTimeLimit = 20; 
let timeLeft = initialTimeLimit; 
let answerRevealed = false;
let hasGuessedOnceThisSession = false; // To control year input guidance visibility (newly added)

// --- GAME MODE GLOBAL VARIABLES ---
const DAILY_CHALLENGE_SONG_COUNT = 5;

let dailyGuessesToday = 0; // Tracks guesses made in the current day's Daily Challenge
let dailyResults = []; // Stores results for the current day's Daily Challenge (5 songs)
let todaysDailySongs = []; // The 5 specific songs for today's Daily Challenge
let inDailyChallengeMode = false; // Flag to indicate if currently playing Daily Challenge

// --- LIFETIME STATS GLOBAL VARIABLES ---
// Stores an array of guess objects: { timestamp, track, correctYear, guessedYear, points, diff, venue, location }
let lifetimeGuessHistory = JSON.parse(localStorage.getItem('gd_lifetimeGuessHistory')) || [];
const MAX_HISTORY_ENTRIES = 1000; // Cap history to prevent excessive localStorage usage

// --- HELPER FUNCTIONS ---

/**
 * Returns today's date in 'YYYY-MM-DD' format (UTC) for consistent seeding.
 */
function getTodayString() {
    const now = new Date();
    return now.getUTCFullYear() + '-' +
           String(now.getUTCMonth() + 1).padStart(2, '0') + '-' +
           String(now.getUTCDate()).padStart(2, '0');
}

/**
 * Returns a date in a readable format like "MM/DD/YY".
 */
function getShortFormattedDate(dateString) {
    const date = new Date(dateString + 'T12:00:00Z'); // Use T12:00:00Z to avoid timezone issues
    const options = { month: '2-digit', day: '2-digit', year: '2-digit' };
    return date.toLocaleDateString('en-US', options);
}

/**
 * Returns a date in a readable format like "July 6th, 2025".
 */
function getLongFormattedDate(dateString) {
    const date = new Date(dateString + 'T12:00:00Z'); 
    
    const day = date.getUTCDate();
    let suffix;
    if (day > 3 && day < 21) suffix = 'th';
    else {
        switch (day % 10) {
            case 1:  suffix = 'st'; break;
            case 2:  suffix = 'nd'; break;
            case 3:  suffix = 'rd'; break;
            default: suffix = 'th';
        }
    }
    return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric' }).replace(/\d+/, day + suffix) + ', ' + date.getFullYear();
}

/**
 * Simple pseudo-random number generator for consistent shuffling based on a seed.
 */
function mulberry32(seed) {
    return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t = (t ^ t >>> 7) + (t ^ t >>> 14);
        return ((t >>> 0) / 4294967296);
    }
}

/**
 * Fisher-Yates shuffle with a seedable random function.
 */
function seededShuffle(array, randomFunc) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex != 0) {
        randomIndex = Math.floor(randomFunc() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [
            array[randomIndex], array[currentIndex]];
    }
    return array;
}

// --- CORE GAME LOGIC ---

document.addEventListener('DOMContentLoaded', async () => {
    await loadTracksJson(); 
    checkDailyStatus(); // Determines if daily challenge is done for today

    // Set initial timed duration and listener
    const timedDurationSelect = document.getElementById('timedDurationSelect');
    initialTimeLimit = parseInt(timedDurationSelect.value); // Set initial limit from default
    timeLeft = initialTimeLimit; // Ensure current time matches initial limit
    
    timedDurationSelect.addEventListener('change', (event) => {
        initialTimeLimit = parseInt(event.target.value); // Update initial time limit
        if (timedMode && !answerRevealed) { // Restart timer with new duration if active
            startTimer();
        }
    });

    updateScoreDisplay(); // Initialize score display
    updateGameModeUI(); // Set initial UI (defaults to Free Play)
});

async function loadTracksJson() {
    try {
        const res = await fetch('tracks.json');
        allTracks = await res.json();
    } catch (error) {
        console.error('Error loading tracks.json:', error);
        document.getElementById('result').textContent = 'Could not load tracks. Please refresh!';
    }
}

/**
 * Manages the daily song queue and user progress.
 */
function checkDailyStatus() {
    const lastPlayDate = localStorage.getItem('gd_lastPlayDate');
    const today = getTodayString();

    todaysDailySongs = getTodaysUniversalSongs(); // Always get today's songs regardless of play status

    if (lastPlayDate === today) {
        dailyGuessesToday = parseInt(localStorage.getItem('gd_dailyGuessesToday')) || 0;
        dailyResults = JSON.parse(localStorage.getItem('gd_dailyResults')) || [];
        sessionPoints = parseInt(localStorage.getItem('gd_sessionPoints')) || 0; // Restore session points
        currentStreak = parseInt(localStorage.getItem('gd_currentStreak')) || 0; // Restore streak

        if (dailyGuessesToday >= DAILY_CHALLENGE_SONG_COUNT) {
            // Daily challenge completed for today, user starts in Free Play
            inDailyChallengeMode = false; 
            document.getElementById('dailyChallengeButton').disabled = true;
            document.getElementById('dailyChallengeButton').textContent = 'Daily Challenge Results'; 
            document.getElementById('dailyChallengeButton').onclick = showDailySummary; // Make button show summary
        } else {
            // Daily challenge not completed, user starts in Free Play by default
            inDailyChallengeMode = false; 
        }
    } else {
        // New day, reset daily challenge data
        localStorage.setItem('gd_lastPlayDate', today);
        localStorage.setItem('gd_dailyGuessesToday', '0');
        localStorage.setItem('gd_dailyResults', '[]');
        dailyGuessesToday = 0;
        dailyResults = [];
        inDailyChallengeMode = false; // New day starts in Free Play
        document.getElementById('dailyChallengeButton').disabled = false;
        document.getElementById('dailyChallengeButton').textContent = 'Play Daily Challenge';
        document.getElementById('dailyChallengeButton').onclick = startDailyChallenge; // Reset click handler
        
        // Don't reset sessionPoints or currentStreak here, those persist across daily/freeplay
    }
    // Always reset availableTracksForSession for Free Play to include all non-daily songs
    availableTracksForSession = [...allTracks]; 
    removeDailySongsFromFreePlayPool(); 
}

/**
 * Starts the Daily Challenge mode.
 */
function startDailyChallenge() {
    if (dailyGuessesToday >= DAILY_CHALLENGE_SONG_COUNT) {
        alert('You have already completed the Daily Challenge for today! Check back tomorrow for a new one, or continue playing in Free Play mode.');
        return;
    }
    inDailyChallengeMode = true;
    // Reset session points/streak for the daily challenge if starting fresh
    sessionPoints = 0;
    currentStreak = 0;
    localStorage.setItem('gd_sessionPoints', '0');
    localStorage.setItem('gd_currentStreak', '0');

    document.getElementById('dailyChallengeButton').disabled = true; // Disable once started
    document.getElementById('dailyChallengeButton').textContent = 'Daily Challenge In Progress';
    document.getElementById('dailyChallengeButton').onclick = null; // Disable click for in-progress
    document.getElementById('goButton').textContent = 'Go'; 
    updateGameModeUI();
    loadTrack(); // Load the first track of the daily challenge
}


/**
 * Gets the 5 universal songs for today's daily challenge.
 * Manages a global shuffled queue in localStorage that all users draw from.
 */
function getTodaysUniversalSongs() {
    const today = getTodayString();
    const dateSeed = parseInt(today.replace(/-/g, '')); 
    const random = mulberry32(dateSeed); 

    let globalQueue = JSON.parse(localStorage.getItem('gd_globalSongQueue')) || [];
    let globalQueueIndex = parseInt(localStorage.getItem('gd_globalQueueIndex')) || 0;
    let lastQueueShuffleDate = localStorage.getItem('gd_lastQueueShuffleDate');

    const currentTrackFilenames = new Set(allTracks.map(t => t.filename));
    const queueFilenames = new Set(globalQueue.map(t => t.filename));
    const missingTracks = [...currentTrackFilenames].filter(f => !queueFilenames.has(f));

    // Check for new tracks or if the queue needs to be re-shuffled (e.g., new day or exhausted)
    if (globalQueue.length === 0 || globalQueueIndex >= globalQueue.length || missingTracks.length > 0 || lastQueueShuffleDate !== today) {
        console.log('Resetting/Updating global song queue due to exhaustion, new tracks, or new day.');
        globalQueue = [...allTracks]; 
        globalQueue = seededShuffle(globalQueue, random); 
        
        if (lastQueueShuffleDate !== today) {
            // For a new day, advance the index to pick new songs from the shuffled queue.
            // If we've reached the end of the queue, loop back to the beginning.
            let previousIndex = parseInt(localStorage.getItem('gd_globalQueueIndex')) || 0;
            globalQueueIndex = (previousIndex + DAILY_CHALLENGE_SONG_COUNT) % globalQueue.length;
            
        } else {
            // If it's the same day but the queue was exhausted/updated, reset index to 0
            // This shouldn't typically happen for daily challenge, but protects against data issues.
            globalQueueIndex = 0;
        }

        localStorage.setItem('gd_globalSongQueue', JSON.stringify(globalQueue));
        localStorage.setItem('gd_globalQueueIndex', globalQueueIndex.toString());
        localStorage.setItem('gd_globalQueueIndex', globalQueueIndex.toString());
        localStorage.setItem('gd_lastQueueShuffleDate', today); 
    }
    
    const dailySongs = [];
    for (let i = 0; i < DAILY_CHALLENGE_SONG_COUNT; i++) {
        const songIndex = (globalQueueIndex + i) % globalQueue.length; 
        dailySongs.push(globalQueue[songIndex]);
    }
    return dailySongs;
}

/**
 * Removes today's daily challenge songs from the available free play pool.
 */
function removeDailySongsFromFreePlayPool() {
    const dailyFilenames = new Set(todaysDailySongs.map(t => t.filename));
    availableTracksForSession = allTracks.filter(track => !dailyFilenames.has(track.filename));
}

function updateGameModeUI() {
    const indicator = document.getElementById('gameModeIndicator');
    const decadeSelect = document.getElementById('decadeSelect');
    const timedOptions = document.querySelector('.timed-options');
    const goButton = document.getElementById('goButton');
    const dailyChallengeButton = document.getElementById('dailyChallengeButton');

    if (inDailyChallengeMode) {
        const guessesMade = dailyGuessesToday;
        indicator.textContent = `Daily Challenge: Song ${guessesMade + 1}/${DAILY_CHALLENGE_SONG_COUNT}`;
        indicator.style.display = 'block'; 
        decadeSelect.style.display = 'none'; 
        timedOptions.style.display = 'none'; 
        goButton.disabled = false; // Always enabled during daily challenge progress
        goButton.textContent = 'Go'; // Always "Go"
        dailyChallengeButton.style.display = 'none'; // Hide daily challenge button
    } else { // Free Play Mode
        indicator.style.display = 'none'; // Hide game mode indicator in Free Play
        decadeSelect.style.display = 'block'; 
        timedOptions.style.display = 'flex'; 
        goButton.disabled = false; // Always enabled in free play
        // Button text changes to "Next Song" or "Play Again" in revealAnswer for Free Play.
        // It's "Go" when no song is loaded yet or after daily challenge completes.
        if (!currentTrack || answerRevealed) { // If no song loaded or after a guess in free play
            goButton.textContent = 'Go';
        } else { // If a song is loaded but not yet guessed (e.g., initial state)
             goButton.textContent = 'Go';
        }

        dailyChallengeButton.style.display = 'block'; // Show daily challenge button
        if (dailyGuessesToday >= DAILY_CHALLENGE_SONG_COUNT) {
            dailyChallengeButton.disabled = false; // Enable to click for results
            dailyChallengeButton.textContent = 'Daily Challenge Results'; 
            dailyChallengeButton.onclick = showDailySummary; // Make button show summary
        } else {
            dailyChallengeButton.disabled = false;
            dailyChallengeButton.textContent = 'Play Daily Challenge';
            dailyChallengeButton.onclick = startDailyChallenge; // Reset click handler
        }
    }
}

/**
 * A single function to load the correct track based on game mode.
 */
function loadTrack() {
    // Clear any existing timer and hide the bar when a new track loads
    clearInterval(timer); 
    document.getElementById('timerBar').style.display = 'none'; 

    let track;
    if (inDailyChallengeMode) {
        if (dailyGuessesToday < DAILY_CHALLENGE_SONG_COUNT) {
            track = todaysDailySongs[dailyGuessesToday];
        } else {
            // This means daily challenge is completed, transition to free play
            inDailyChallengeMode = false; // Exit daily challenge mode
            updateGameModeUI();
            showDailySummary(); // Show the daily summary results
            return;
        }
    } else { // Free Play Logic
        // Ensure we have enough tracks, reshuffle if needed.
        if (availableTracksForSession.length < 1) { // Check if pool is empty
            availableTracksForSession = [...allTracks]; 
            removeDailySongsFromFreePlayPool(); // Always exclude daily songs from free play pool
            const currentDecade = document.getElementById('decadeSelect').value;
            if (currentDecade) { // Reapply decade filter if active
                availableTracksForSession = availableTracksForSession.filter(t => t.year.startsWith(currentDecade));
            }
            if (availableTracksForSession.length === 0) {
                 document.getElementById('result').textContent = 'No more tracks available for selected filters! Try "All Decades."';
                 document.getElementById('goButton').disabled = true;
                 return;
            }
            // No alert for new cycle in free play to avoid annoyance
        }
        
        // Pick a random track from the available pool
        const randIndex = Math.floor(Math.random() * availableTracksForSession.length);
        track = availableTracksForSession[randIndex];
        availableTracksForSession.splice(randIndex, 1); // Remove from pool
    }

    if (!track) {
        document.getElementById('result').textContent = 'No more tracks available!';
        return;
    }
    
    currentTrack = track;
    answerRevealed = false;
    document.getElementById('audio').src = `audio/${track.filename}`;
    document.getElementById('audio').load();
    document.getElementById('audio').play().catch(() => {});
    document.getElementById('result').textContent = ''; // Clear previous result message
    document.getElementById('result').className = 'neutral';
    document.getElementById('yearGuess').value = '';
    document.getElementById('checkButton').disabled = false;
    document.getElementById('songInfoDisplay').textContent = ''; // Clear previous song info

    // Hide year input guidance when a new song starts
    document.getElementById('yearInputGuidance').style.display = 'none';

    if (timedMode) startTimer(); // Start/reset timer ONLY if timed mode is active
}

function revealAnswer() {
    if (!currentTrack || answerRevealed) return;
    answerRevealed = true;
    clearInterval(timer);
    document.getElementById('timerBar').style.display = 'none';
    document.getElementById('checkButton').disabled = true;

    // Show year input guidance after the first guess, only once per session in Free Play
    if (!hasGuessedOnceThisSession && !inDailyChallengeMode) {
        document.getElementById('yearInputGuidance').style.display = 'block';
        hasGuessedOnceThisSession = true; 
    }

    let guessInput = document.getElementById('yearGuess').value.trim();
    let guessedYearNum = parseInt(guessInput, 10);
    let displayGuess = guessInput; // What we show to the user

    // Handle 2-digit year input for display only, still use 4-digit for calculation
    if (/^\d{2}$/.test(guessInput)) {
        guessedYearNum = (guessedYearNum >= 65 && guessedYearNum <= 99 ? 1900 : 2000) + guessedYearNum;
        displayGuess = guessInput; // Keep 2-digit for display if that was input
    } else if (!/^\d{4}$/.test(guessInput) || isNaN(guessedYearNum)) {
        guessedYearNum = null; // No valid guess
        displayGuess = 'No guess';
    }

    const correctYear = parseInt(currentTrack.year, 10);
    const difference = guessedYearNum !== null ? Math.abs(guessedYearNum - correctYear) : Infinity;

    let pointsEarned = 0;
    let resultClass = 'incorrect';
    let message = 'Not Quite!';
    let isPerfect = false;
    let isClose = false; // For +/- 1 or 2
    let isEra = false; // For +/- 3 to 5

    if (guessedYearNum === correctYear) {
        pointsEarned = 100;
        resultClass = 'correct';
        message = 'Correct!';
        isPerfect = true;
        currentStreak++;
    } else if (difference <= 1) {
        pointsEarned = 75;
        resultClass = 'close-guess';
        message = `Very Close! (${difference} year${difference === 1 ? '' : 's'} off)`;
        isClose = true;
        currentStreak = 0; // Reset streak on non-perfect
    } else if (difference <= 2) {
        pointsEarned = 50;
        resultClass = 'close-guess';
        message = `Close! (${difference} year${difference === 1 ? '' : 's'} off)`;
        isClose = true;
        currentStreak = 0;
    } else if (difference <= 5) { 
        pointsEarned = 25;
        resultClass = 'era-guess';
        message = `Era Match! (${difference} year${difference === 1 ? '' : 's'} off)`;
        isEra = true;
        currentStreak = 0;
    } else {
        pointsEarned = 0;
        resultClass = 'incorrect';
        message = `Not Quite! (${guessedYearNum !== null ? difference : '??'} year${difference === 1 ? '' : 's'} off)`;
        currentStreak = 0;
    }

    sessionPoints += pointsEarned;
    
    // Update global high score if session points exceed it
    if (sessionPoints > siteHighestScore) {
        siteHighestScore = sessionPoints;
        localStorage.setItem('gd_site_highest_score', siteHighestScore);
    }
    localStorage.setItem('gd_sessionPoints', sessionPoints);
    localStorage.setItem('gd_currentStreak', currentStreak);

    // Store daily result if in daily challenge
    if (inDailyChallengeMode) {
        dailyResults.push({
            correct: isPerfect,
            close: isClose,
            era: isEra, 
            guess: displayGuess,
            points: pointsEarned,
            trackInfo: {
                track: currentTrack.track,
                year: currentTrack.year,
                date: currentTrack.date,
                venue: currentTrack.venue,
                location: currentTrack.location
            }
        });
        dailyGuessesToday++; 
        localStorage.setItem('gd_dailyGuessesToday', dailyGuessesToday.toString());
        localStorage.setItem('gd_dailyResults', JSON.stringify(dailyResults));

        if (dailyGuessesToday >= DAILY_CHALLENGE_SONG_COUNT) {
            inDailyChallengeMode = false; // Daily challenge completed
            updateGameModeUI(); // Transition UI to free play
            showDailySummary(); // Show the daily summary results
        }
    }


    // Store lifetime guess history
    lifetimeGuessHistory.push({
        timestamp: new Date().toISOString(),
        track: currentTrack.track,
        correctYear: currentTrack.year,
        guessedYear: displayGuess,
        points: pointsEarned,
        diff: guessedYearNum !== null ? difference : null,
        venue: currentTrack.venue,
        location: currentTrack.location
    });

    // Prune history if it gets too large
    if (lifetimeGuessHistory.length > MAX_HISTORY_ENTRIES) {
        console.warn('Lifetime guess history is getting large. Pruning oldest entries.');
        lifetimeGuessHistory = lifetimeGuessHistory.slice(lifetimeGuessHistory.length - MAX_HISTORY_ENTRIES / 2); // Keep last half
    }
    localStorage.setItem('gd_lifetimeGuessHistory', JSON.stringify(lifetimeGuessHistory));


    const resultEl = document.getElementById('result');
    resultEl.className = resultClass;
    resultEl.textContent = `${message}\nYour Guess: ${displayGuess} ‚Äî Correct Year: ${currentTrack.year}\nPoints: ${pointsEarned}`;
    
    // Display song info separately
    document.getElementById('songInfoDisplay').textContent = `Song: ${currentTrack.track}\nDate: ${currentTrack.date}\n${currentTrack.venue}, ${currentTrack.location}`;

    updateScoreDisplay();

    // Change "Go" button to "Next Song" or "Play Again" in Free Play after a guess
    if (!inDailyChallengeMode) {
        document.getElementById('goButton').textContent = 'Next Song';
    }
}

function showDailySummary() {
    const modal = document.getElementById('dailySummaryModal');
    document.getElementById('summaryDate').textContent = `(${getLongFormattedDate(getTodayString())})`; // Use long format for modal title
    const graphicEl = document.getElementById('summaryGraphic');
    const detailsEl = document.getElementById('summaryDetails');
    
    let dailyPerfectCount = dailyResults.filter(r => r.correct).length;
    let dailyCloseCount = dailyResults.filter(r => r.close || r.era).length; // Combine close and era for the graphic
    let dailyMissCount = dailyResults.filter(r => r.points === 0).length;

    let graphicBlocksHtml = '';
    dailyResults.forEach((r, index) => {
        let blockClass = 'miss';
        let blockText = 'Miss';
        if (r.correct) {
            blockClass = 'perfect';
            blockText = 'Perfect';
        } else if (r.close || r.era) {
            blockClass = 'close';
            blockText = 'Close';
        }
        graphicBlocksHtml += `
            <div class="summary-block ${blockClass}">
                ${index + 1}<br>${r.points}pts
            </div>
        `;
    });
    graphicEl.innerHTML = graphicBlocksHtml;

    let totalDailyPoints = dailyResults.reduce((sum, r) => sum + r.points, 0);

    detailsEl.innerHTML = `
        <strong>Your Daily Score: ${totalDailyPoints} Points</strong><br>
        Perfect Guesses: ${dailyPerfectCount}<br>
        Close Guesses: ${dailyCloseCount}<br>
        Misses: ${dailyMissCount}<br>
        <hr>
        <h3>Your Guesses:</h3>
        ${dailyResults.map((result, index) => {
            let statusIcon = '‚ùå';
            if (result.correct) statusIcon = '‚úÖ';
            else if (result.close || result.era) statusIcon = 'üî∂'; 
            return `<p style="margin-bottom: 0.5em;">
                        ${statusIcon} <strong>Guess ${index + 1}:</strong> ${result.trackInfo.track}<br>
                        Date: ${getShortFormattedDate(result.trackInfo.date)} | Venue: ${result.trackInfo.venue}<br>
                        Your Guess: ${result.guess} | Correct: ${result.trackInfo.year} | Points: ${result.points}
                    </p>`;
        }).join('<hr style="border-style: dashed; margin: 0.8em 0;">')}
    `;
    modal.style.display = 'block';
}

function closeDailySummaryAndEnterFreePlay() {
    document.getElementById('dailySummaryModal').style.display = 'none';
    inDailyChallengeMode = false; // Ensure we are in free play mode
    removeDailySongsFromFreePlayPool(); // Ensure daily songs are excluded from Free Play
    updateGameModeUI(); // Update UI to free play mode
    document.getElementById('goButton').textContent = 'Go'; // Reset button to 'Go' for new Free Play session
    document.getElementById('result').textContent = 'Daily Challenge complete! Welcome to Free Play.';
    document.getElementById('songInfoDisplay').textContent = ''; // Clear song info if coming from daily summary
}


function showStatsModal() {
    const modal = document.getElementById('statsModal');
    const statsDetailsEl = document.getElementById('statsDetails');

    const totalGames = lifetimeGuessHistory.length;
    const totalLifetimePoints = lifetimeGuessHistory.reduce((sum, guess) => sum + guess.points, 0);
    const lifetimePerfectGuesses = lifetimeGuessHistory.filter(g => g.points === 100).length;
    const lifetimeCloseGuesses = lifetimeGuessHistory.filter(g => g.points === 75 || g.points === 50).length;
    const lifetimeEraMatches = lifetimeGuessHistory.filter(g => g.points === 25).length;
    const lifetimeIncorrect = lifetimeGuessHistory.filter(g => g.points === 0).length;
    
    const perfectAccuracy = totalGames > 0 ? ((lifetimePerfectGuesses / totalGames) * 100).toFixed(1) : 0;
    const overallSuccessRate = totalGames > 0 ? (((lifetimePerfectGuesses + lifetimeCloseGuesses + lifetimeEraMatches) / totalGames) * 100).toFixed(1) : 0;

    // Calculate average difference for valid numerical guesses
    const validDifferences = lifetimeGuessHistory
        .filter(g => g.diff !== null && !isNaN(g.diff) && g.points < 100) // Exclude perfect guesses from average diff
        .map(g => g.diff);
    const averageDifference = validDifferences.length > 0 ? (validDifferences.reduce((sum, diff) => sum + diff, 0) / validDifferences.length).toFixed(1) : 'N/A';

    // Calculate most common incorrect decade (from 0-point guesses)
    const incorrectDecadeCounts = {};
    lifetimeGuessHistory.forEach(guess => {
        if (guess.points === 0 && guess.guessedYear !== 'No guess' && guess.guessedYear && !isNaN(parseInt(guess.guessedYear, 10))) {
            const guessedYear = parseInt(guess.guessedYear, 10);
            const decade = Math.floor(guessedYear / 10) * 10 + 's';
            incorrectDecadeCounts[decade] = (incorrectDecadeCounts[decade] || 0) + 1;
        }
    });
    let mostCommonIncorrectDecade = 'N/A';
    let maxIncorrectCount = 0;
    for (const decade in incorrectDecadeCounts) {
        if (incorrectDecadeCounts[decade] > maxIncorrectCount) {
            maxIncorrectCount = incorrectDecadeCounts[decade];
            mostCommonIncorrectDecade = decade;
        }
    }

    // Determine highest streak across lifetime
    let lifetimeHighestStreak = 0;
    let currentConsecutivePerfect = 0;
    for (let i = 0; i < lifetimeGuessHistory.length; i++) {
        if (lifetimeGuessHistory[i].points === 100) { // Only count perfect guesses for streak
            currentConsecutivePerfect++;
        } else {
            currentConsecutivePerfect = 0;
        }
        if (currentConsecutivePerfect > lifetimeHighestStreak) {
            lifetimeHighestStreak = currentConsecutivePerfect;
        }
    }
    localStorage.setItem('gd_lifetimeHighestStreak', lifetimeHighestStreak);


    // Prepare yearly breakdown
    const yearlyBreakdown = lifetimeGuessHistory.reduce((acc, guess) => {
        if (guess.correctYear) {
            const year = guess.correctYear;
            acc[year] = acc[year] || { games: 0, points: 0 };
            acc[year].games++;
            acc[year].points += guess.points;
        }
        return acc;
    }, {});
    const sortedYears = Object.keys(yearlyBreakdown).sort();

    // Prepare venue breakdown
    const venueBreakdown = lifetimeGuessHistory.reduce((acc, guess) => {
        if (guess.venue) {
            const venue = guess.venue;
            acc[venue] = acc[venue] || { games: 0, points: 0 };
            acc[venue].games++;
            acc[venue].points += guess.points;
        }
        return acc;
    }, {});
    const sortedVenues = Object.keys(venueBreakdown).sort((a,b) => venueBreakdown[b].points - venueBreakdown[a].points); // Sort by points descending

    // Guess Distribution Calculation
    const distribution = {
        '100 Points': lifetimePerfectGuesses,
        '75 Points': lifetimeGuessHistory.filter(g => g.points === 75).length,
        '50 Points': lifetimeGuessHistory.filter(g => g.points === 50).length,
        '25 Points': lifetimeGuessHistory.filter(g => g.points === 25).length,
        '0 Points': lifetimeIncorrect
    };
    let distributionHtml = '<h3>Guess Distribution</h3>';
    if (totalGames > 0) {
        for (const [category, count] of Object.entries(distribution)) {
            const percentage = ((count / totalGames) * 100).toFixed(1);
            distributionHtml += `<p>${category}: ${count} (${percentage}%)</p>`;
        }
    } else {
        distributionHtml += '<p>No guesses yet to show distribution.</p>';
    }

    // Top 5 Most Guessed Songs (Correctly/Incorrectly)
    const songAccuracy = {}; // { 'Song Name': { correctCount: 0, incorrectCount: 0, totalCount: 0 } }
    lifetimeGuessHistory.forEach(guess => {
        const songKey = `${guess.track} (${guess.correctYear})`;
        songAccuracy[songKey] = songAccuracy[songKey] || { correctCount: 0, incorrectCount: 0, totalCount: 0 };
        songAccuracy[songKey].totalCount++;
        if (guess.points === 100) {
            songAccuracy[songKey].correctCount++;
        } else if (guess.points === 0) {
            songAccuracy[songKey].incorrectCount++;
        }
    });

    const sortedByCorrect = Object.entries(songAccuracy)
        .sort(([,a], [,b]) => b.correctCount - a.correctCount || b.totalCount - a.totalCount)
        .slice(0, 5);

    const sortedByIncorrect = Object.entries(songAccuracy)
        .sort(([,a], [,b]) => b.incorrectCount - a.incorrectCount || b.totalCount - a.totalCount)
        .slice(0, 5);

    let topSongsHtml = '<h3>Top Songs</h3>';
    if (lifetimeGuessHistory.length > 0) {
        topSongsHtml += `
            <h4>Most Guessed Correctly:</h4>
            <table>
                <thead><tr><th>Song</th><th>Correct Guesses</th></tr></thead>
                <tbody>
                    ${sortedByCorrect.map(([song, data]) => `<tr><td>${song}</td><td>${data.correctCount}</td></tr>`).join('')}
                </tbody>
            </table>
            <h4>Most Guessed Incorrectly:</h4>
            <table>
                <thead><tr><th>Song</th><th>Incorrect Guesses</th></tr></thead>
                <tbody>
                    ${sortedByIncorrect.map(([song, data]) => `<tr><td>${song}</td><td>${data.incorrectCount}</td></tr>`).join('')}
                </tbody>
            </table>
        `;
    } else {
        topSongsHtml += '<p>No songs guessed yet to show top lists.</p>';
    }


    let statsHtml = `
        <h3>Overall Performance</h3>
        <p><strong>Total Games Played:</strong> ${totalGames}</p>
        <p><strong>Total Points Earned:</strong> ${totalLifetimePoints}</p>
        <p><strong>Highest Perfect Guess Streak:</strong> ${lifetimeHighestStreak}</p>
        <p><strong>Average Year Difference (when not perfect):</strong> ${averageDifference} years</p>
        <p><strong>Most Common Incorrect Decade:</strong> ${mostCommonIncorrectDecade}</p>
        <p><em>(Stats are updated after each guess and saved in your browser.)</em></p>
        
        <hr>
        ${distributionHtml}

        <hr>
        ${topSongsHtml}

        <hr>
        <h3>Year-by-Year Performance</h3>
        <table>
            <thead><tr><th>Year</th><th>Games</th><th>Points</th></tr></thead>
            <tbody>
                ${sortedYears.map(year => `<tr><td>${year}</td><td>${yearlyBreakdown[year].games}</td><td>${yearlyBreakdown[year].points}</td></tr>`).join('')}
            </tbody>
</table>

        <hr>
        <h3>Top Venues (by Points)</h3>
        <table>
            <thead><tr><th>Venue</th><th>Games</th><th>Points</th></tr></thead>
            <tbody>
                ${sortedVenues.map(venue => `<tr><td>${venue}</td><td>${venueBreakdown[venue].games}</td><td>${venueBreakdown[venue].points}</td></tr>`).join('')}
            </tbody>
        </table>

        <hr>
        <h3>Full Guess History</h3>
        <div style="max-height: 200px; overflow-y: auto; text-align: left; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 0.5em;">
            ${lifetimeGuessHistory.length === 0 ? '<p>No guess history yet.</p>' :
                lifetimeGuessHistory.slice().reverse().map(g => `
                    <p style="border-bottom: 1px dashed rgba(255,255,255,0.1); padding-bottom: 5px; margin-bottom: 5px;">
                        <strong>${getLongFormattedDate(g.timestamp.split('T')[0])}:</strong> ${g.track} (${g.correctYear})<br>
                        Guessed: ${g.guessedYear} | Points: ${g.points} ${g.diff !== null ? `(${g.diff} off)` : ''}
                        <br><small>${g.venue}, ${g.location}</small>
                    </p>
                `).join('')
            }
        </div>
    `;

    statsDetailsEl.innerHTML = statsHtml;
    modal.style.display = 'block';
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
}

function showScoringInfoModal() {
    document.getElementById('scoringInfoModal').style.display = 'block';
}

function copyShareLink(event, isFromResultModal) {
    event.preventDefault();
    let shareText;
    if (isFromResultModal && dailyResults.length > 0) {
        const graphic = dailyResults.map(r => {
            if (r.correct) return 'üü©';
            if (r.close || r.era) return 'üü®';
            return 'üü•';
        }).join('');
        const totalDailyPoints = dailyResults.reduce((sum, r) => sum + r.points, 0);
        const dailyPerfect = dailyResults.filter(r => r.correct).length;
        const dailyClose = dailyResults.filter(r => r.close).length;
        const dailyEra = dailyResults.filter(r => r.era).length;

        shareText = `DeadGuessr Daily Challenge ${getLongFormattedDate(getTodayString())}\nMy Round Score: ${totalDailyPoints} points! (${dailyPerfect} Perfect, ${dailyClose} Close, ${dailyEra} Era)\n${graphic}\n\nPlay here: ${window.location.href}`;
    } else {
        shareText = `I'm testing my Dead knowledge on DeadGuessr! Come play along and guess the year: ${window.location.href}`;
    }

    navigator.clipboard.writeText(shareText).then(() => {
        alert('Results copied to clipboard!');
    }).catch(err => console.error('Failed to copy: ', err));
}

function updateScoreDisplay() {
    // Determine highest streak across lifetime from stored history
    let lifetimeHighestStreak = 0;
    let currentConsecutivePerfect = 0;
    for (let i = 0; i < lifetimeGuessHistory.length; i++) {
        if (lifetimeGuessHistory[i].points === 100) { // Only count perfect guesses for streak
            currentConsecutivePerfect++;
        } else {
            currentConsecutivePerfect = 0;
        }
        if (currentConsecutivePerfect > lifetimeHighestStreak) {
            lifetimeHighestStreak = currentConsecutivePerfect;
        }
    }
    localStorage.setItem('gd_lifetimeHighestStreak', lifetimeHighestStreak);

    // Animate score changes
    animateNumber('sessionScoreValue', parseInt(document.getElementById('sessionScoreValue').textContent), sessionPoints, 500);
    animateNumber('highestScoreValue', parseInt(document.getElementById('highestScoreValue').textContent), siteHighestScore, 500);
    animateNumber('streakValue', parseInt(document.getElementById('streakValue').textContent), currentStreak, 500);
}

// Function to animate numbers
function animateNumber(elementId, start, end, duration) {
    const obj = document.getElementById(elementId);
    if (!obj) return;

    let startTime = null;

    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    function animate(currentTime) {
        if (!startTime) startTime = currentTime;
        const progress = Math.min((currentTime - startTime) / duration, 1);
        const easedProgress = easeInOutQuad(progress);
        
        obj.textContent = Math.floor(easedProgress * (end - start) + start);

        if (progress < 1) {
            requestAnimationFrame(animate);
        } else {
            obj.textContent = end; // Ensure final value is exactly 'end'
        }
    }
    requestAnimationFrame(animate);
}


function toggleTimedMode(btn) {
    if (inDailyChallengeMode) { 
        alert('Timed mode is only available in Free Play mode.');
        return;
    }
    timedMode = !timedMode;
    btn.classList.toggle('active', timedMode);
    const timedDurationSelect = document.getElementById('timedDurationSelect');

    if (timedMode) {
        timedDurationSelect.style.display = 'inline-block'; 
        initialTimeLimit = parseInt(timedDurationSelect.value); 
        timeLeft = initialTimeLimit; 
        if (!answerRevealed && currentTrack) startTimer(); 
    } else {
        timedDurationSelect.style.display = 'none'; 
        clearInterval(timer);
        document.getElementById('timerBar').style.display = 'none';
    }
}

function startTimer() {
    clearInterval(timer); 
    timeLeft = initialTimeLimit; 
    const bar = document.getElementById('timerBar');
    bar.style.display = 'block';
    bar.style.width = '100%';

    timer = setInterval(() => {
        timeLeft--;
        bar.style.width = `${(timeLeft / initialTimeLimit) * 100}%`; 
        if (timeLeft <= 0) {
            clearInterval(timer);
            if(!answerRevealed) revealAnswer();
            bar.style.display = 'none';
        }
    }, 1000);
}

function filterByDecade(decadePrefix) {
    if (inDailyChallengeMode) { 
        document.getElementById('decadeSelect').value = ''; 
        alert('Decade filtering is only available in Free Play mode.');
        return;
    }

    availableTracksForSession = [...allTracks];
    removeDailySongsFromFreePlayPool(); // Always exclude daily songs from free play pool

    if (decadePrefix) {
        availableTracksForSession = availableTracksForSession.filter(t => t.year.startsWith(decadePrefix));
    }
    document.getElementById('decadeSelect').value = decadePrefix;
    document.getElementById('result').textContent = `Filter set to ${decadePrefix ? decadePrefix + '0s' : 'All Decades'} for Free Play. Press "Go" to get a song.`;
    // Clear current track if a filter is applied in middle of a guess
    document.getElementById('audio').pause();
    document.getElementById('audio').removeAttribute('src');
    currentTrack = null;
    document.getElementById('songInfoDisplay').textContent = '';
    document.getElementById('yearGuess').value = '';
    document.getElementById('checkButton').disabled = true;
    document.getElementById('goButton').textContent = 'Go'; // Reset button to 'Go' when filter changes
    document.getElementById('yearInputGuidance').style.display = 'none'; // Hide guidance
    hasGuessedOnceThisSession = false; // Reset guidance flag for new filter
}

document.addEventListener('keydown', function(event) {
    if (document.activeElement === document.getElementById('yearGuess') && event.key === 'Enter') {
        event.preventDefault();
        if (!answerRevealed) revealAnswer();
    }
});
</script>

<footer style="font-size: 0.8em; text-align: center; margin-top: 2em; color: #ccc;">
  <a href="https://github.com/Gignac77" target="_blank" rel="noopener noreferrer" style="color: #ccc; text-decoration: none;">
    Built with Love by Matt
  </a>
</footer>
</body>
</html>
